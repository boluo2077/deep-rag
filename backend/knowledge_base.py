import aiofiles
from pathlib import Path
from typing import List, Dict
from backend.config import settings

class KnowledgeBase:
    def __init__(self, base_path: str = None):
        self.base_path = Path(base_path or settings.knowledge_base_chunks)
        self.summary_file = Path(settings.knowledge_base_file_summary)
    
    async def get_file_summary(self) -> str:
        """
        Get knowledge base file summary
        
        The summary file needs to be generated by an independent script:
        Knowledge-Base-File-Summary/generate.py
        
        If the summary file does not exist, return a prompt message
        """
        if self.summary_file.exists():
            async with aiofiles.open(self.summary_file, 'r', encoding='utf-8') as f:
                return await f.read()
        
        return (
            "⚠️ Knowledge Base Summary file not found.\n\n"
            "Please generate it first by running:\n"
            "Knowledge-Base-File-Summary/generate.py\n\n"
            f"Expected file path: {self.summary_file}"
        )
    
    async def retrieve_files(self, file_paths: List[str]) -> str:
        results = []
        
        for file_path in file_paths:
            full_path = self.base_path / file_path.lstrip('/')
            
            if full_path.is_dir():
                print(f"[DEBUG] Retrieving directory: {file_path}")
                md_files = list(full_path.rglob("*.md"))
                print(f"[DEBUG] Found {len(md_files)} files in {file_path}")
                for md_file in md_files:
                    content = await self._read_file(md_file)
                    relative_path = md_file.relative_to(self.base_path)
                    results.append(f"《{relative_path}》\n\n{content}")
                    print(f"[DEBUG] Added file: {relative_path}, length: {len(content)}")
            
            elif full_path.is_file():
                print(f"[DEBUG] Retrieving file: {file_path}")
                content = await self._read_file(full_path)
                results.append(f"《{file_path}》\n\n{content}")
                print(f"[DEBUG] File length: {len(content)}")
            
            elif file_path == "/":
                print(f"[DEBUG] Retrieving all files")
                for md_file in self.base_path.rglob("*.md"):
                    content = await self._read_file(md_file)
                    relative_path = md_file.relative_to(self.base_path)
                    results.append(f"《{relative_path}》\n\n{content}")
        
        final_content = "\n\n==========\n\n".join(results)
        print(f"[DEBUG] Total content length: {len(final_content)}, files: {len(results)}")
        return final_content
    
    async def _read_file(self, file_path: Path) -> str:
        try:
            async with aiofiles.open(file_path, 'r', encoding='utf-8') as f:
                return await f.read()
        except Exception as e:
            return f"Error reading file: {str(e)}"
    
    def list_files(self) -> Dict:
        def scan_dir(path: Path) -> Dict:
            result = {"type": "directory", "name": path.name, "children": []}
            
            if not path.exists():
                return result
            
            items = sorted(path.iterdir(), key=lambda x: (not x.is_dir(), x.name))
            
            for item in items:
                if item.name.startswith('.'):
                    continue
                
                if item.is_dir():
                    result["children"].append(scan_dir(item))
                else:
                    result["children"].append({
                        "type": "file",
                        "name": item.name,
                        "path": str(item.relative_to(self.base_path))
                    })
            
            return result
        
        return scan_dir(self.base_path)

knowledge_base = KnowledgeBase()
